<html>
<head>
	<title>Ticket-Designer</title>
	<style>
		.editor {
			display: flex;
			flex-direction: row;
		}
	
		#editor-container {
			flex: 2;
		}
		
		#editor-inputs {
			flex: 1;
		}
	</style>
</head>
<body>
	<div>
		Upload Configfile: <input type='file' accept="application/json" multiple id="configFileUpload" />
	</div>
	<template id="editorTemplate">
		<div style="padding: 10px;">
			Upload Image: <input type='file' class="image-file-upload" />
			<button class="select-move-mode-button">Select and Move</button>
			<button class="add-text-mode-button">Add Text</button>
			<button onclick="addText()">Add Text</button>
			<button onclick="downloadOutput()">Download</button>
		</div>
		<canvas width="900" height="600" style="border: 1px solid black;"></canvas>
		<aside class="editor-tools">
			<form class="text-form">
				<div>
					<label>Key:</label><input type="text" name="key" required />
				</div>
				<div>
					Boundingbox:
				</div>
				<div>
					top-left:
				</div>
				
				<div>
					<label>x:</label><input type="number" name="topleft-x" required />
					<label>y:</label><input type="number" name="topleft-y" required />
				</div>
				
				<div>
					bottom-right:
				</div>
				
				<div>
					<label>x:</label><input type="number" name="bottomright-x" required />
					<label>y:</label><input type="number" name="bottomright-y" required />
				</div>
			</form>
		</aside>
	</template>
	<div class="editor">
		<div id="editor-container">
		
		</div>
	</div>
	
	<script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha256-pasqAKBDmFT4eHoN2ndd6lN370kFiGUFyTiUHWhU7k8=" crossorigin="anonymous"></script>
	<script>
	
	// TODO: bounding boxes sollten nur bis an den Rand verschoben werden k√∂nnen
	
	function FileUploadInput(element, reader) {
		element.addEventListener('change', function(event) {
			reader.read(event.target.files);
		});
	}
	
	
	function ConfigFilesReader() {
		
		this._files = [];
		
		this.read = function(files) {
			var self = this;
		
			for(var fileIndex = 0; fileIndex < files.length; fileIndex++) {

				var reader = new FileReader();
				reader.onload = function(event) {
					var jsonObj = JSON.parse(event.target.result);
					self._files.push(jsonObj);
					console.dir(jsonObj);
				}

				reader.readAsText(files[fileIndex]);
			}
		};
		
		this.files = function() {
			return this._files;
		};
		
		this.clear = function() {
			return this._files = [];
		};
	}
	
	
	function ImageFilesReader(callback) {
		
		this.read = function(files) {
			var self = this;
		
			for(var fileIndex = 0; fileIndex < files.length; fileIndex++) {

				var reader = new FileReader();
				reader.onload = function(event) {
					var img = new Image();
					img.src = event.target.result;
					img.onload = function() {
						callback.call(null, this);
					};
				}

				reader.readAsDataURL(files[fileIndex]);
			}
		};
	}
	
	
	function FileDownloader(mediatype = 'text/plain', charset = 'utf-8') {
		
		this.download = function(filename, text) {
			var element = document.createElement('a');
			element.setAttribute('href', 'data:' + mediatype + ';charset=' + charset + ',' + encodeURIComponent(text));
			element.setAttribute('download', filename);

			element.style.display = 'none';
			document.body.appendChild(element);

			element.click();

			document.body.removeChild(element);
		}
	}
	FileDownloader.jsonUtf8 = new FileDownloader('application/json', 'utf-8');
	
	
	function TextSerializer() {
	
		function textsToString(texts) {
			var out = "";
			for(var textIndex = 0; textIndex < texts.length; textIndex++) {
				out += textToString(texts[textIndex]) + "\n";
			}
			return out;
		}
		
		function textToString(text) {
			var out = "";
			out += "name="+text.name + "\n";
			out += "boundingbox="+text.topLeft.x + ","+text.topLeft.y + ","+text.bottomRight.x + ","+text.bottomRight.y +"\n";
			return out;
		}
	
		this.serialize = function(text) {
			if(Array.isArray(text)) {
				return textsToString(text);
			} else {
				return textToString(text);
			}
		};
	}
	
	
	function DrawableRectangle(rectangle) {
	
		this.topLeft = rectangle.topLeft;
		this.bottomRight = rectangle.bottomRight;
	
		this.draw = function(ctx) {
			var topLeft = rectangle.topLeft;
			var bottomRight = rectangle.bottomRight;
			var x = topLeft.x;
			var y = topLeft.y;
			var width = bottomRight.x - topLeft.x;
			var height = bottomRight.y - topLeft.y;
		
			var lineWidth = 2;
		
			ctx.beginPath();
			ctx.rect(x, y, width, height);
			ctx.strokeStyle = 'black';
			ctx.lineWidth = lineWidth;
			ctx.stroke();
			
			ctx.beginPath();
			ctx.rect(x + lineWidth, y + lineWidth, width - 2*lineWidth, height - 2*lineWidth);
			ctx.strokeStyle = 'white';
			ctx.lineWidth = lineWidth;
			ctx.stroke();
		};
		
		this.containsPoint = function(point) {
			return this.topLeft.x <= point.x
				&& this.topLeft.y <= point.y
				&& this.bottomRight.x >= point.x
				&& this.bottomRight.y >= point.y;
		};
		
		this.moveBy = function(dx, dy) {
			this.topLeft.x += dx;
			this.topLeft.y += dy;
			this.bottomRight.x += dx;
			this.bottomRight.y += dy;
		};
		
		this.boundingBox = function() {
			return {
				topLeft: this.topLeft,
				bottomRight: this.bottomRight
			};
		}

	}
	
	
	function DrawableImage(img) {
		
		this.x = 0;
		this.y = 0;
		this.width = img.width;
		this.height = img.height;
		
		this.draw = function(ctx) {
			ctx.drawImage(img, this.x, this.y);
		};
		
		this.containsPoint = function(point) {
			return this.x <= point.x
				&& this.y <= point.y
				&& this.x + this.width >= point.x
				&& this.y + this.height >= point.y;
		};
	}
	
	
	function NoopDrawingMode() {
		
	}
	
	function RectangleDrawingMode(drawingCanvas) {
		
		var lastMouse;
		var mousedown = false;
		var currentRectangle;
		
		this.mousedown = function(mouse) {
			lastMouse = mouse;
			mousedown = true;
		};

		this.mouseup = function(mouse) {
			mousedown = false;
		};

		this.mousemove = function(mouse) {
			
			if (mousedown) {
				
				var newRectangle = new DrawableRectangle({
					topLeft: {
						x: Math.min(lastMouse.x, mouse.x),
						y: Math.min(lastMouse.y, mouse.y)
					},
					bottomRight: {
						x: Math.max(lastMouse.x, mouse.x),
						y: Math.max(lastMouse.y, mouse.y)
					}
				});
				
				if(currentRectangle) {
					drawingCanvas.replace(currentRectangle, newRectangle);
				} else {
					drawingCanvas.add(newRectangle);
				}
				
				currentRectangle = newRectangle;
			}
		};
	}
	
	
	function SelectAndMoveMode(drawingCanvas) {
		
		var drawable;
		var lastMouse;
		var mousedown = false;
		
		this.mousedown = function(mouse) {
			lastMouse = mouse;
			mousedown = true;
			drawable = drawingCanvas.findByPosition(mouse);
		};

		this.mouseup = function(mouse) {
			mousedown = false;
		};

		this.mousemove = function(mouse) {
			
			if (mousedown && drawable) {

				var dx = mouse.x - lastMouse.x;
				var dy = mouse.y - lastMouse.y;

				drawingCanvas.moveBy(drawable, dx, dy);
				lastMouse = mouse;
			}
		};
	}
	
	
	function DrawingCanvas(canvas) {
		
		var width = canvas.width;
		var height = canvas.height;
		var ctx = canvas.getContext("2d");
		var drawables = [];
		var layers = [ { visible: true, drawables: [] } ];
		var currentLayerIndex = 0;
		
		function foreachLayer(fn, backToFront = true) {
			if(backToFront) {
				for(var layerIndex = 0; layerIndex < layers.length; layerIndex++) {
					var layer = layers[layerIndex];
					
					if(layer.visible) {
						var returnValue = fn.call(this, layer);
						if(returnValue) {
							return returnValue;
						}
					}
				}
			} else {
				for(var layerIndex = layers.length - 1; layerIndex >= 0; layerIndex--) {
					var layer = layers[layerIndex];
					
					if(layer.visible) {
						var returnValue = fn.call(this, layer);
						if(returnValue) {
							return returnValue;
						}
					}
				}
			}
		}
		
		function foreachDrawable(fn, backToFront = true) {
			var self = this;
			
			return foreachLayer(function(layer) {
				
				if(backToFront) {
					for(var i = 0; i < layer.drawables.length; i++) {
						var drawable = layer.drawables[i];
						var returnValue = fn.call(self, drawable);
						if(returnValue) {
							return returnValue;
						}
					}
				} else {
					for(var i = layer.drawables.length - 1; i >= 0; i--) {
						var drawable = layer.drawables[i];
						var returnValue = fn.call(self, drawable);
						if(returnValue) {
							return returnValue;
						}
					}
				}
			}, backToFront);
		}
		
		this.width = function() {
			return width;
		}
		
		this.height = function() {
			return height;
		}
		
		this.draw = function() {
			ctx.clearRect(0, 0, this.width(), this.height());

			foreachDrawable(function(drawable) {
				drawable.draw(ctx);
			});
		};
		
		this.add = function(drawable) {
			layers[currentLayerIndex].drawables.push(drawable);
		};
		
		this.replace = function(oldDrawable, newDrawable) {
		
			for(var layerIndex = 0; layerIndex < layers.length; layerIndex++) {
				var layer = layers[layerIndex];
				
				var index = layer.drawables.indexOf(oldDrawable);
				if (index > -1) {
					layer.drawables.splice(index, 1, newDrawable);
					return;
				}
			}
		};
		
		this.findByPosition = function(point) {
			var self = this;
			
			return foreachDrawable(function(drawable) {
			
				if(drawable.containsPoint && drawable.containsPoint(point)) {
					return drawable;
				}
				
			}, false);
		};
		
		this.moveBy = function(drawable, dx, dy) {
		
			if(drawable && drawable.moveBy && drawable.boundingBox) {
			
				var boundingBox = drawable.boundingBox();
				var topLeft = boundingBox.topLeft;
				var bottomRight = boundingBox.bottomRight;
				
				if(dx > 0) {
					if(bottomRight.x >= this.width()) {
						dx = Math.min(0, - (bottomRight.x - this.width()));
					}
				} else {
					if(topLeft.x <= 0) {
						dx = Math.max(0, - topLeft.x);
					}
				}
				
				if(dy > 0) {
					if(bottomRight.y >= this.height()) {
						dy = Math.min(0, - (bottomRight.y - this.height()));
					}
				} else {
					if(topLeft.y <= 0) {
						dy = Math.max(0, - topLeft.y);
					}
				}
				
				drawable.moveBy(dx, dy);
				
			} else {
				throw new Error('Tried to move incompatible drawable');
			}
		};
	}
	
	
	function InteractionCanvas(canvas) {
		
		var modes = [];
		var lastMouse;
		var currentMouse;
		
		var currentText;
		
		this.setMode = function(mode) {
			modes = [ mode ];
		}
		
		function position() {
			return {
				x: canvas.offsetLeft,
				y: canvas.offsetTop
			};
		}
		
		function relativeMousePosition(event) {
			var canvaspos = position();
			return {
				x: parseInt(event.clientX - canvaspos.x),
				y: parseInt(event.clientY - canvaspos.y)
			};
		}
		
		function foreachMode(fn) {
			for(var i = 0; i < modes.length; i++) {
				fn.call(null, modes[i]);
			}
		}

		canvas.addEventListener('mousedown', function(event) {
			lastMouse = relativeMousePosition(event);
			
			foreachMode(function (mode) {
				if(mode.mousedown) {
					mode.mousedown(lastMouse);
				}
			});
		});

		canvas.addEventListener('mouseup', function(event) {
			currentMouse = relativeMousePosition(event);
			
			foreachMode(function (mode) {
				if(mode.mouseup) {
					mode.mouseup(currentMouse);
				}
			});
		});

		canvas.addEventListener('mousemove', function(event) {
			currentMouse = relativeMousePosition(event);
			
			foreachMode(function (mode) {
				if(mode.mousemove) {
					mode.mousemove(currentMouse);
				}
			});
		});
	}
	
	
	function EditorTools(element, textFormElement) {
		var textForm = new TextForm(textFormElement);
	}
	
	function TextForm(form) {
		
		var changeListeners = [];
		var elements = form.elements;
		
		function getInputElementByName(name) {
			
			for(var i = 0; i < elements.length; i++) {
				var element = elements[i];
				if(element.name == name) {
					return element;
				}
			}
		}
		
		function notifyChange() {
			var key = this.keyInput.value;
			var topLeftX = this.topLeftXInput.value;
			var topLeftY = this.topLeftYInput.value;
			var bottomRightX = this.bottomRightXInput;
			var bottomRightY = this.bottomRightYInput;
		
			for(var i = 0; i < changeListeners.length; i++) {
				var changeListener = changeListeners[i];
				if(changeListener) {
					changeListener.call(null, key, { x: topLeftX, y: topLeftY }, { x: bottomRightX, y: bottomRightY });
				}
			}
		}
		
		this.keyInput = getInputElementByName('key');
		this.topLeftXInput = getInputElementByName('topleft-x');
		this.topLeftYInput = getInputElementByName('topleft-y');
		this.bottomRightXInput = getInputElementByName('bottomright-x');
		this.bottomRightYInput = getInputElementByName('bottomright-y');
		
		this.keyInput.addEventListener('change', function(newValue) {
			notifyChange();
		});
		
		this.topLeftXInput.addEventListener('change', function(newValue) {
			notifyChange();
		});
		
		this.topLeftYInput.addEventListener('change', function(newValue) {
			notifyChange();
		});
		
		this.bottomRightXInput.addEventListener('change', function(newValue) {
			notifyChange();
		});
		
		this.bottomRightYInput.addEventListener('change', function(newValue) {
			notifyChange();
		});
		
		this.onChange = function(fn) {
			changeListeners.push(fn);
		};
		
		this.setValue = function(text) {
			this.keyInput.value = text.key;
			this.topLeftXInput.value = text.boundingBox.topLeft.x;
			this.topLeftYInput.value = text.boundingBox.topLeft.y;
			this.bottomRightXInput.value = text.boundingBox.bottomRight.x;
			this.bottomRightYInput.value = text.boundingBox.bottomRight.y;
		};
		
	}
	
	function Editor(id, canvas, imageFileUploadElement, selectMoveModeButton, addTextModeButton, editorTools) {
	
		var drawingCanvas = new DrawingCanvas(canvas);
		
		var imageFilesReader = new ImageFilesReader(function(img) {
			var image = new DrawableImage(img);
			drawingCanvas.add(image);
		});
		var imageFileUpload = new FileUploadInput(imageFileUploadElement, imageFilesReader);
		
		var interactionCanvas = new InteractionCanvas(canvas);
		var rectangleDrawingMode = new RectangleDrawingMode(drawingCanvas);
		var selectMoveMode = new SelectAndMoveMode(drawingCanvas);
		interactionCanvas.setMode(rectangleDrawingMode);
		
		selectMoveModeButton.addEventListener('click', function() {
			interactionCanvas.setMode(selectMoveMode);
		});
		
		addTextModeButton.addEventListener('click', function() {
			interactionCanvas.setMode(rectangleDrawingMode);
		});
		
		this.draw = function() {
			drawingCanvas.draw();
		};
	}
	
	
	function createEditor(id, templateElement, container) {
		var elementId = 'editor-' + id;
		
		var editorElement = document.createElement('div');
		editorElement.id = elementId;
		container.appendChild(editorElement);
		
		var editorContent = templateElement.content.cloneNode(true);
		editorElement.appendChild(editorContent);
		
		var canvas  = document.getElementById(elementId).querySelector("canvas");
		var imageFileUploadElement = document.getElementById(elementId).querySelector('.image-file-upload');
		var selectMoveModeButton = document.getElementById(elementId).querySelector('.select-move-mode-button');
		var addTextModeButton = document.getElementById(elementId).querySelector('.add-text-mode-button');
		var editorToolsElement = document.getElementById(elementId).querySelector('.editor-tools');
		var textFormElement = editorToolsElement.querySelector('.text-form');
		
		var editorTools = new EditorTools(editorToolsElement, textFormElement);
		
		return new Editor(id, canvas, imageFileUploadElement, selectMoveModeButton, addTextModeButton, editorTools);
	}
	
	
	function main() {
		var editors = [];
	
		var configFilesReader = new ConfigFilesReader();
		var configFileUpload = new FileUploadInput(document.getElementById('configFileUpload'), configFilesReader);
		
		var container = document.getElementById('editor-container');
		var templateElement = document.getElementById('editorTemplate');
		var editor = createEditor(editors.length + 1, templateElement, container);
	
		editors.push(editor);
		
		function animate() {
			requestAnimationFrame(animate);
			
			for(var i = 0; i < editors.length; i++) {
				editors[i].draw();
			}
		}
		animate();
	}
	main();
	
	
	
	
	
	
	function MetaConfiguration() {
		
		this.texts = [];
	}
	
	function MetaText(key, boundingBox) {
		
		this.key = key;
		this.boundingBox = boundingBox;
	}
	
	var meta = {
		texts: []
	};

	
	function downloadOutput() {
		var filename = prompt("Please enter filename", "");
		if(filename) {
			FileDownloader.jsonUtf8.download(filename, metaToString(meta));
		}
	}
	
	function metaToString(meta) {
		var out = "";
		out += "texts: \n"
		out += new TextSerializer().serialize(meta.texts);
		return out;
	}
	
	function addText() {
		var name = prompt("Please enter name", "");
		if(name) {
			currentText.name = name;
			meta.texts.push(currentText);
		}
		currentText = undefined
	}
	
	</script>
</body>
</html>